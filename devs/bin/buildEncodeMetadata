#!/usr/bin/env python3
import sys
import os.path as osp
import json
import argparse
from collections import defaultdict

sys.path.insert(0, osp.normpath(osp.join(osp.dirname(__file__), "../../lib")))
from lrgasp.objDict import ObjDict
from lrgasp import LrgaspException
from lrgasp.defs import Platform, LibraryPrep, Sample, Species
from lrgasp.symEnum import SymEnumJsonEncoder
from lrgasp.data_sets import LrgaspRun, LrgaspReplicate, LrgaspRnaSeqFile

ENCODE_URL = "https://www.encodeproject.org"

def parse_args():
    desc = """Convert JSON dumps of the ENCODE metadata to a subset for use in validating
    submissions.  This allows for faster parsing and making non-ENCODE libraries consistent"""
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("--dataset_json", default="/dev/stdout",
                        help="combined metadata JSON, see src/lrgasp/data_matrix.py")
    parser.add_argument("encode_jsons", nargs="+",
                        help="per-run dumps of encode metadata")
    return parser.parse_args()


def determine_species(encode_md, sample):
    """figure out the species"""
    species = set()
    for rep in encode_md.replicates:
        if "biosample" in rep.library:
            biosample = rep.library.biosample
            if "organism" in biosample.donor:
                species.add(biosample.donor.organism.name)
    if len(species) == 0:
        if sample == Sample.H1_mix:
            return Species.human
        else:
            raise LrgaspException("Unable to determine species")
    elif len(species) > 1:
        raise LrgaspException(f"expecting only one species, got {species}")
    else:
        return Species(list(species)[0])

def determine_sample(encode_md):
    "map to LRGASP samples"
    biosample = encode_md.biosample_summary
    if biosample == "Castaneus X S129/SvJae F121-9":
        return Sample.ES
    elif biosample == "H1 and endodermal cell":
        return Sample.H1_mix
    elif biosample == "WTC11":
        return Sample.WTC11
    else:
        raise LrgaspException(f"unable to determine sample from biosample_summary: {biosample}")

def _guess_library_prep_from_one_desc(desc):
    if desc.startswith("Direct RNA"):
        return LibraryPrep.dRNA
    elif desc.startswith("LRGASP CapTrap"):
        return LibraryPrep.CapTrap
    else:
        return None

def guess_library_prep_from_desc(encode_md):
    desc = None
    if "description" in encode_md:
        prep = _guess_library_prep_from_one_desc(encode_md.description)
        if prep is not None:
            return prep, encode_md.description
    for file_md in encode_md.files:
        desc = file_md.replicate.get("description")
        if desc is not None:
            prep = _guess_library_prep_from_one_desc(desc)
            if prep is not None:
                return prep, desc
    return LibraryPrep.cDNA, None

def library_prep_from_construction_method(encode_md):
    methods = set()
    for rep in encode_md.replicates:
        cm = rep.library.get("construction_method")
        if cm is not None:
            methods.add(cm)
    if len(methods) > 1:
        raise LrgaspException("expected to parse zero one construction_method, got {methods}")
    elif len(methods) == 0:
        return LibraryPrep.cDNA
    cm = list(methods)[0]
    if cm == "CapTrap":
        return LibraryPrep.CapTrap
    elif cm == "Nanopore Direct RNA Kit":
        return LibraryPrep.dRNA
    elif cm == "Nanopore PCR-cDNA Kit":
        return LibraryPrep.cDNA
    elif cm == "R2C2":
        return LibraryPrep.R2C2
    else:
        raise LrgaspException(f"Unknown construction_method: {cm}")

def determine_library_prep(encode_md):
    "probe metadata to determine construction method"
    desc_meth, desc = guess_library_prep_from_desc(encode_md)
    cons_meth = library_prep_from_construction_method(encode_md)
    if desc_meth != cons_meth:
        if desc is None:
            print(f"Note: {encode_md.accession}: library construction method '{cons_meth}' used, no description: {encode_md.encode_json}", file=sys.stderr)
        else:
            print(f"Note: {encode_md.accession}: library construction method '{cons_meth}' does match description guess '{desc_meth}' from '{desc}': {encode_md.encode_json}", file=sys.stderr)
    return cons_meth

def determine_platform(encode_md):
    platforms = set()
    for file_md in encode_md.files:
        platforms.add(file_md.platform.term_name)
    if len(platforms) != 1:
        raise LrgaspException("expected to parse one platform name, got {platform}")
    pt = list(platforms)[0]
    if pt == 'Oxford Nanopore MinION':
        return Platform.ONT
    elif pt == 'Pacific Biosciences Sequel II':
        return Platform.PacBio
    elif pt == 'Illumina HiSeq 2500':
        return Platform.Illumina
    else:
        raise LrgaspException(f"can't convert platform {pt}")

def get_replicate(file_md):
    rep = file_md.replicate
    if rep.technical_replicate_number != 1:
        raise LrgaspException(f"expecting only one technical_replicate_number, got {rep.technical_replicate_number}")
    return rep.biological_replicate_number

def parse_paired_end(file_md):
    # "paired_with" : "/files/ENCFF644AQW/",
    return (file_md.paired_end, file_md.paired_with.split('/')[2])

def build_file(run, file_md):
    file_acc = file_md.accession
    if not file_acc.startswith("ENCFF"):
        raise LrgaspException(f"accession should start with ENCFF, got {file_acc}")

    paired_end = paired_with = None
    if "paired_end" in file_md:
        paired_end, paired_with = parse_paired_end(file_md)

    return LrgaspRnaSeqFile(file_acc=file_acc,
                            file_type=file_md.file_type,
                            url=ENCODE_URL + file_md.href,
                            s3_uri=file_md.s3_uri,
                            file_size=file_md.file_size,
                            md5sum=file_md.md5sum,
                            run_acc=run.run_acc,
                            biological_replicate_number=get_replicate(file_md),
                            output_type=file_md.output_type.replace(' ', '_'),
                            paired_end=paired_end, paired_with=paired_with)

def build_files(encode_md, run, replicate_map):
    """build files and add to replicates"""
    for file_md in encode_md.files:
        frec = build_file(run, file_md)
        replicate_map[frec.biological_replicate_number].files.append(frec)

def build_replicates(encode_md):
    """replicates are a group of files"""
    replicate_map = {}
    for replicate in encode_md.replicates:
        rep = LrgaspReplicate(replicate.biological_replicate_number,
                              replicate.library.get("size_range"))
        replicate_map[rep.replicate_number] = rep
    return replicate_map

def build_run(encode_md):
    run_acc = encode_md.accession
    if not run_acc.startswith("ENCSR"):
        raise LrgaspException(f"accession should start with ENCSR, got {run_acc}")
    sample = determine_sample(encode_md)
    platform = determine_platform(encode_md)
    library_prep = determine_library_prep(encode_md)
    species = determine_species(encode_md, sample)
    # FIXME: tmp until R2C2 is fixed
    description = encode_md.get("description", encode_md.accession)
    run = LrgaspRun(species=species, sample=sample, run_acc=run_acc,
                    description=description, library_prep=library_prep,
                    platform=platform)
    replicate_map = build_replicates(encode_md)
    run.replicates = [replicate_map[r] for r in sorted(replicate_map.keys())]
    build_files(encode_md, run, replicate_map)
    return run

def process_encode_run(encode_json):
    with open(encode_json) as fh:
        encode_md = json.load(fh, object_pairs_hook=ObjDict)
        encode_md.encode_json = encode_json
    return build_run(encode_md)

def load_encode_run(runs, encode_json):
    try:
        run = process_encode_run(encode_json)
        if run.run_acc in runs:
            raise LrgaspException("duplicate run: " + run.run_acc)
        runs[run.run_acc] = run
    except Exception:
        raise LrgaspException("error processing: " + encode_json)

def main(args):
    runs = {}
    for encode_json in args.encode_jsons:
        load_encode_run(runs, encode_json)

    with open(args.dataset_json, "w") as fh:
        json.dump(list(runs.values()), fh, cls=SymEnumJsonEncoder, indent=4)

main(parse_args())
